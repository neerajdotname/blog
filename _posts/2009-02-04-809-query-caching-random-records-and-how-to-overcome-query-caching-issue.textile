---
layout: post
title: Query caching, random records and how to overcome query caching issue
---

I have users table and on the homepage I need to display three random users every single time someone comes to the homepage. Since I am using mysql I can make use of <tt>rand()</tt> feature. Here is the code I had in my controller.

{% highlight ruby %}
random_user1 = User.find(:first, :order => 'rand()')
random_user2 = User.find(:first, :order => 'rand()')
random_user3 = User.find(:first, :order => 'rand()')
{% endhighlight %}

However the result surprised me. All three sql statements brought the same record.

h2. Problem Definition

I want to get three random records but I get same record in all three database calls.

h2. Query Caching

ActiveRecord has "query caching":http://github.com/rails/rails/blob/ed5fa2fe339e0aabde657ffdec24ac591d390d73/activerecord/lib/active_record/query_cache.rb feature which enables ActiveRecord to cache the sql and the returned data for the current thread. Within that thread if ActiveRecord finds the same sql statement then ActiveRecord doesn't event hit database and returns the data from the cache.

Here is how query caching is implemented in ActiveRecord.

{% highlight ruby %}
module ActiveRecord
  class QueryCache
    module ClassMethods
      # Enable the query cache within the block if Active Record is configured.
      def cache(&block)
        if ActiveRecord::Base.configurations.blank?
          yield
        else
          connection.cache(&block)
        end
      end
 
      # Disable the query cache within the block if Active Record is configured.
      def uncached(&block)
        if ActiveRecord::Base.configurations.blank?
          yield
        else
          connection.uncached(&block)
        end
      end
    end
 
    def initialize(app)
      @app = app
    end
 
    def call(env)
      ActiveRecord::Base.cache do
        @app.call(env)
      end
    end
  end
end
{% endhighlight %}

This is how <tt>cache</tt> method can be used.

{% highlight ruby %}
User.cache do
  ...
end
{% endhighlight %}

Any sql statement generated inside the block will be cached by the ActiveRecord.


h2. Where is Rails calling the cache method 

Rails wraps the whole controller action call inside cache statement. Checkout this snippet of code from <tt>/lib/action_controller/caching/sql_cache.rb</tt>

{% highlight ruby %}
module ActionController #:nodoc:
  module Caching
    module SqlCache
      def self.included(base) #:nodoc:
        if defined?(ActiveRecord) && ActiveRecord::Base.respond_to?(:cache)
          base.alias_method_chain :perform_action, :caching
        end
      end
 
      protected
        def perform_action_with_caching
          ActiveRecord::Base.cache do
            perform_action_without_caching
          end
        end
    end
  end
end
{% endhighlight %}

As you can see using <tt>alias_method_chain</tt> the whole perform_action method in wrapped inside cache block. Since the sql generated by the three sql statements in my case was same, ActiveRecord was not even hitting the database. First time ActiveRecord hits the database but on subsequent two requests the result is returned from the cache. This is the reason why all three sql statements above resulted in the same record.

h2. Solution

Along with cache there is another method called <tt>uncached</tt> . As the name suggests block executed within uncached method is not executed.

{% highlight ruby %}
User.uncached do
 random_user1 = User.find(:first, :order => 'rand()')
 random_user2 = User.find(:first, :order => 'rand()')
 random_user3 = User.find(:first, :order => 'rand()')
end
{% endhighlight %}
