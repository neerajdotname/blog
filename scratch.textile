---
layout: post
title:  JavaScript - How it works and how to make your JavaScript code work 
---


h1. Variable hoisting

h1. Execution Context

h1. Closure

If the variable x referenced at run time why the result is not 20 in this case.
...example

Also mention that two closures can possibly change the data .





h1. If you do not declare var then you create a global variable. Not true.

Most of the JavaScript book would say that if you forget to declare <tt>var</tt> then you accidentally you have created a global varialbe. Well that is not entirely true. What you are creating is a  property on a global object which is <tt>window</tt> in the case of browser.

Here is how you an find out by skipping a variable you are not creating a variable. I discussed previously that all variable declaration are get hoisted. Notice what happens in this case.

<pre>
alert(a); // undefined
alert(b); // 'b' is not defined


var a = 'hello world';
b = 'I am global';
</pre>


 
data[0](); // 3, but not 0
data[1](); // 3, but not 1
data[2](); // 3, but not 2



The reason why <tt>alert(b)</tt> failed is because as far as ECMAScript is concerned <tt>b</tt> is not a variable.

h1. Alawys declare global properties using window .

If you really want to create a global variable called foo the don't do this.

<pre>
foo = 'I am global';
</pre>

When I look at that code, I'm never sure if the developer accidentally missed adding a <tt>var</tt> . To make it clear to the users that you meant to delcare a global variable do this.

<pre>
window.foo = 'I am global';
</pre>



<pre>
function funky(o) {
  o = null;
}

var x = 'hello';
funky(x);

console.log(x);

this is how it works
x is a variable. great.
get me the memory address x is pointing to
pass that memory address to the function
that is why inside the function you can't change
anything about x. Note that the memory address of 
the value held by x is passed and not the memory address of 
x itself.
</pre>


Objects aren't passed by reference, they are passed value-by-reference. If they were passed by reference, you would be able to change the variable itself - not just the properties. – Andy E's head Mar 11 at 9:43
6	
"Passing in an object, however, passes it in by reference." No, this is a common misconception. JavaScript only has pass-by-value. It's just that the value, in the case of an object reference, is an object reference (pointer). That's completely different from "pass by reference" which allows you to update the caller's copy of the actual parameter from within the callee. If you can't change the thing being passed in (for instance, to make it point to a different object), it's pass-by-value. You can change the properties of the object, but not the value of the caller's reference to it. – 


http://stackoverflow.com/questions/2423868/pass-variables-by-reference-in-javascript/2423892#2423892

http://snook.ca/archives/javascript/javascript_pass
pick more examples from this one.
http://snook.ca/archives/javascript/javascript_pass



Reference:

http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/

http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/

h2. Answer 1

Scope is saved at function creation time. Scope property is already written and stored in function object.

